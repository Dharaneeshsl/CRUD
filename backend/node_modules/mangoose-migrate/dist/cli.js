#!/usr/bin/env node

// src/cli.ts
import { Command } from "commander";
import mongoose2 from "mongoose";

// src/core/recorder.ts
import mongoose from "mongoose";
var MigrationRecorder = class {
  constructor(connection) {
    this.connection = connection;
    this.model = null;
  }
  async init() {
    const schema = new mongoose.Schema({
      name: { type: String, required: true, unique: true },
      appliedAt: { type: Date, default: Date.now }
    });
    this.model = this.connection.model("Migration", schema);
    await this.model.createCollection();
  }
  async isApplied(migrationName) {
    const count = await this.model.countDocuments({ name: migrationName });
    return count > 0;
  }
  async markAsApplied(migrationName) {
    await this.model.create({ name: migrationName });
  }
  async markAsUnApplied(migrationName) {
    await this.model.deleteOne({ name: migrationName });
  }
  async getAppliedMigrations() {
    const docs = await this.model.find().sort("appliedAt");
    return docs.map((doc) => doc.name);
  }
};

// src/core/loader.ts
import fs from "fs/promises";
import path from "path";
var MigrationLoader = class {
  constructor(migrationsPath) {
    this.migrationsPath = migrationsPath;
  }
  async getMigrationFiles() {
    try {
      const files = await fs.readdir(this.migrationsPath);
      return files.filter((file) => file.endsWith(".js")).sort();
    } catch (err) {
      if (err.code === "ENOENT") {
        await fs.mkdir(this.migrationsPath, { recursive: true });
        return [];
      }
      throw err;
    }
  }
  async loadMigration(fileName) {
    const migrationPath = path.join(this.migrationsPath, fileName);
    const migrationUrl = new URL(`file://${path.resolve(migrationPath)}`);
    try {
      const module = await import(migrationUrl.href);
      return new module.default();
    } catch (err) {
      throw new Error(`Migration ${fileName} has no default export: ${err}`);
    }
  }
};

// src/commands/migrate.ts
var MigrateCommand = class {
  constructor(connection, config) {
    this.connection = connection;
    this.config = config;
  }
  async execute() {
    const recorder = new MigrationRecorder(this.connection);
    await recorder.init();
    const loader = new MigrationLoader(this.config.migrationsPath);
    const migrationFiles = await loader.getMigrationFiles();
    const appliedMigrations = await recorder.getAppliedMigrations();
    for (const file of migrationFiles) {
      if (appliedMigrations.indexOf(file)) continue;
      try {
        const migration = await loader.loadMigration(file);
        await migration.up(this.connection);
        for (const operation of migration.operations) {
          operation.applyUp(this.connection);
        }
        await recorder.markAsApplied(file);
        console.log(`Migration applied: ${file}`);
      } catch (err) {
        console.error(`Failed to apply migration ${file}: ${err}`);
        throw err;
      }
    }
  }
};

// src/commands/make.ts
import fs2 from "fs/promises";
import path2 from "path";
var MIGRATION_TEMPLATE = `import { Migration } from "mangoose-migrate/core";
import { CreateModel, AddField } from "mangoose-migrate/operations";

export default class {{className}} extends Migration {
  constructor() {
    super('{{name}}');
  }

  async up(db) {
    // Add your migration operations here
    // this.addOperation(new CreateModel('User', { name: String }));
    // this.addOperation(new AddField('User', 'email', { type: String }));
  }

  async down(db) {
    // Add rollback operations here
  }
}
`;
var MakeCommand = class {
  constructor(config) {
    this.config = config;
  }
  async execute(name) {
    await fs2.mkdir(this.config.migrationsPath, { recursive: true });
    const files = await fs2.readdir(this.config.migrationsPath);
    const nextNum = files.length + 1;
    const migrationNum = nextNum.toString().padStart(4, "0");
    const _name = name.toLowerCase().replace(/[^a-z0-9]+/g, "_").replace(/^_+|_+$/g, "").replace(/_+/g, "_");
    const filename = `${migrationNum}_${_name}.js`;
    const filepath = path2.join(this.config.migrationsPath, filename);
    const className = name.split("-").map((part) => part.charAt(0).toUpperCase() + part.slice(1)).join(" ");
    const content = MIGRATION_TEMPLATE.replace(/{{className}}/g, className).replace(
      /{{name}}/g,
      name
    );
    await fs2.writeFile(filepath, content);
    console.log(`Created migration: ${filename}`);
  }
};

// src/config.ts
import path3 from "path";
var CONFIG_FILES = ["mangoose.config.js"];
async function loadConfig(configPath) {
  const defaultConfig = {
    migrationsPath: "./migrations",
    options: {
      authSource: "admin",
      bufferCommands: false
    }
  };
  let customConfig = {};
  try {
    const configFile = configPath || CONFIG_FILES[0];
    const fullPath = path3.resolve(process.cwd(), configFile);
    const importConfingModule = await import(fullPath);
    customConfig = importConfingModule.default || importConfingModule;
  } catch {
    if (configPath) {
      throw new Error(`Failed to load config file: ${configPath}`);
    } else {
    }
  }
  if (!customConfig.connectionUri && process.env.MONGODB_URI) {
    customConfig.connectionUri = process.env.MONGODB_URI;
  }
  if (!customConfig.connectionUri) {
    throw new Error(
      "Database connection uri must be provided in config or MONGODB_URI env variable"
    );
  }
  return { ...defaultConfig, ...customConfig };
}

// src/utils.ts
async function gracefulExit(connection, code) {
  try {
    await connection.close();
    process.exit(code);
  } catch (err) {
    console.error(`Failed to close connection: ${err}`);
    process.exit(code === 0 ? 1 : code);
  }
}
async function promptOverride(message) {
  console.warn(`${message} (y/N) `);
  process.stdin.setEncoding("utf8");
  return new Promise((resolve) => {
    process.stdin.once("data", (data) => {
      resolve(data.toString().trim().toLowerCase() === "y");
    });
  });
}

// src/commands/init.ts
import fs3 from "fs/promises";
import path4 from "path";
var CONFIG_TEMPLATE = `export default {
  connectionUri: process.env.MONGODB_URI,
  migrationsPath: "./migrations",
  options: {
    authSource: "admin",
    retryWrites: true,
    // ...
  },
};`;
var InitCommand = class {
  async execute() {
    const configPath = path4.resolve(process.cwd(), CONFIG_FILES[0]);
    try {
      await fs3.access(configPath);
      console.warn(`Config file already exists at ${CONFIG_FILES[0]}`);
      const override = await promptOverride("Override existing config file?");
      if (!override) {
        throw new Error("Init cancelled");
      }
    } catch (err) {
      if (err.code !== "ENOENT") throw err;
    }
    await fs3.writeFile(configPath, CONFIG_TEMPLATE);
    console.log(`Configuration file created at ./${CONFIG_FILES[0]}`);
    console.info(
      "Edit this file with your MongoDB connection details before running migrations."
    );
  }
};

// package.json
var package_default = {
  name: "mangoose-migrate",
  version: "0.1.7",
  description: "A lightweight migration tool for Mongoose (MongoDB), inspired by Django's migration system.",
  keywords: [
    "mongoose",
    "mongodb",
    "migrations",
    "schema",
    "cli"
  ],
  homepage: "https://github.com/moonlitgrace/mangoose-migrate#readme",
  bugs: {
    url: "https://github.com/moonlitgrace/mangoose-migrate/issues"
  },
  repository: {
    type: "git",
    url: "git+https://github.com/moonlitgrace/mangoose-migrate.git"
  },
  license: "MIT",
  author: "moonlitgrace",
  type: "module",
  bin: {
    "mangoose-migrate": "./dist/cli.js"
  },
  files: [
    "dist"
  ],
  exports: {
    "./core": {
      import: "./dist/core/index.js",
      types: "./dist/core/index.d.ts"
    },
    "./operations": {
      import: "./dist/operations/index.js",
      types: "./dist/operations/index.d.ts"
    }
  },
  scripts: {
    build: "tsup",
    lint: "eslint . --max-warnings 0",
    format: "prettier --write . --ignore-path ./.gitignore",
    test: 'echo "Error: no test specified" && exit 1',
    prepublishOnly: "npm run build",
    changeset: "changeset",
    "release:version": "changeset version",
    "release:publish": "npm run build && changeset publish"
  },
  devDependencies: {
    "@changesets/cli": "^2.29.4",
    "@eslint/compat": "^1.2.9",
    "@eslint/js": "^9.27.0",
    "@types/node": "^22.15.21",
    eslint: "^9.27.0",
    globals: "^16.2.0",
    prettier: "^3.5.3",
    tsup: "^8.5.0",
    typescript: "^5.8.3",
    "typescript-eslint": "^8.32.1"
  },
  dependencies: {
    commander: "^14.0.0",
    dotenv: "^16.5.0",
    mongoose: "^8.15.0"
  },
  publishConfig: {
    access: "public"
  }
};

// src/cli.ts
import dotenv from "dotenv";
dotenv.config();
var program = new Command();
program.name("mangoose-migrate").description(package_default.description).version(package_default.version).option("-c, --config <path>", "path to config file");
program.command("init").description("Initialize the migration config").action(async () => {
  try {
    const cmd = new InitCommand();
    await cmd.execute();
    process.exit(0);
  } catch (err) {
    console.error(err);
    process.exit(1);
  }
});
program.command("make <name>").description("Create a new migration file").action(async (name) => {
  const options = program.opts();
  const config = await loadConfig(options.config);
  const connection = await mongoose2.createConnection(config.connectionUri, {
    ...config.options
  }).asPromise();
  connection.on("error", (err) => {
    console.error(`MongoDB connection error: ${err}`);
    process.exit(1);
  });
  try {
    const cmd = new MakeCommand(config);
    await cmd.execute(name);
    await gracefulExit(connection, 0);
  } catch (err) {
    console.error(`Error creating migration: ${err}`);
    await gracefulExit(connection, 1);
  }
});
program.command("migrate").description("Run pending migrations").action(async () => {
  const options = program.opts();
  const config = await loadConfig(options.config);
  const connection = await mongoose2.createConnection(config.connectionUri, {
    ...config.options
  }).asPromise();
  connection.on("error", (err) => {
    console.error(`MongoDB connection error: ${err}`);
    process.exit(1);
  });
  try {
    const cmd = new MigrateCommand(connection, config);
    await cmd.execute();
    await gracefulExit(connection, 0);
  } catch (err) {
    console.error(`Migration failed: ${err}`);
    await gracefulExit(connection, 1);
  }
});
program.parseAsync(process.argv).catch((err) => {
  console.error(err);
  process.exit(1);
});
